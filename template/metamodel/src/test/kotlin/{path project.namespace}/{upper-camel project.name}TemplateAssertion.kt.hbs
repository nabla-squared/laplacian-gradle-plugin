{{#*inline "PROJECT_NAME"}}{{upper-camel project.name}}{{/inline}}
{{#*inline "CLASS_NAME"}}{{> PROJECT_NAME}}TemplateAssertion{{/inline}}
{{#*inline "MODEL_CLASS_NAME"}}{{> PROJECT_NAME}}Model{{/inline}}
{{#*inline "MODEL_LOADER_CLASS_NAME"}}{{> MODEL_CLASS_NAME}}Loader{{/inline}}

package {{project.namespace}}
import com.github.jknack.handlebars.Context
import laplacian.util.*
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import java.io.File
import java.nio.file.FileSystems
import java.nio.file.Files
import java.nio.file.Paths
import java.util.stream.Collectors

/**
 * A test utility class to assert the content of files which are generated by the templates.
 */
class {{> CLASS_NAME}}() {

    lateinit var model: {{> MODEL_CLASS_NAME}}
    lateinit var context: Context

    /**
     * Read the model object from the given yaml files.
     */
    fun withModel(files: List<File>): {{> CLASS_NAME}} {
        model = {{> MODEL_LOADER_CLASS_NAME}}().load(files)
        context = TemplateWrapper.createContext(model)
        return this
    }

    /**
     * Read the model object from the given yaml files.
     */
    fun withModel(path: String, glob: String = "{*,**/*}.yml"): {{> CLASS_NAME}} {
        val m = FileSystems.getDefault().getPathMatcher("glob:$path/$glob")
        model = {{> MODEL_LOADER_CLASS_NAME}}().load(
            Files.walk(Paths.get(path))
                 .filter { m.matches(it) }
                 .map{ it.toFile() }
                 .collect(Collectors.toList())
        )
        context = TemplateWrapper.createContext(model)
        return this
    }

    /**
     * Read the model object from the given yaml expression.
     */
    fun withModelText(text: String): {{> CLASS_NAME}} {
        val temp = File.createTempFile({{> CLASS_NAME}}::javaClass.name, ".yml")
        temp.deleteOnExit()
        temp.writeText(text)
        model = {{> MODEL_LOADER_CLASS_NAME}}().load(listOf(temp))
        context = TemplateWrapper.createContext(model)
        return this
    }

    lateinit var template: File

    /**
     * Set the test target template file.
     */
    fun withTemplate(templatePath: String): {{> CLASS_NAME}} {
        template = File(templatePath)
        return this
    }

    /**
     * Assert that the contents of the given file and generated one are same.
     */
    fun assertSameContent(toBeSourceCodePath: String, handleModel:(model: {{> MODEL_CLASS_NAME}}) -> Map<String, Any?> = { emptyMap() }) {
        val actual = template.readText().handlebars().apply(Context.newContext(context, handleModel(model)))
        val expect = File(toBeSourceCodePath).readText()
        assertEquals(expect.stripDocComments(), actual.stripDocComments())
    }

    /**
     * Assert that the content of the generated file contains the given string.
     */
    fun assertContains(content: String, handleModel:(model: {{> MODEL_CLASS_NAME}}) -> Map<String, Any?> = { emptyMap() }) {
        val actual = template.readText().handlebars().apply(Context.newContext(context, handleModel(model))).stripDocComments()
        val expect = content.stripDocComments()
        val result = actual.replace("""(\n|^)\s*""".toRegex(), "\n").contains(expect.replace("""(\n|^)\s*""".toRegex(), "\n"))
        assertTrue(result, "\n---\n$expect\n---\nThe above content should be included in the following generated code:\n---\n${actual}")
    }
}
